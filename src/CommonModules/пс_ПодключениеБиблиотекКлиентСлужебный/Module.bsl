
// Описание
// 
// Параметры:
// 	ИмяКаталога	-	Строка
// 	ДополнительныеПараметры	-	Структура
Процедура РаспаковкаБиблиотекПослеПолученияВременногоКаталога(ИмяКаталога, ДополнительныеПараметры) Экспорт
	
	ДополнительныеПараметры.Вставить("ИмяКаталога", ИмяКаталога);
	
	МассивБиблиотек = Новый Массив;
	ПриОпределенииВнешнихБиблиотек(МассивБиблиотек);
	ДополнительныеПараметры.Вставить("МассивБиблиотек", МассивБиблиотек);
	РаспаковатьБиблиотеки(ДополнительныеПараметры);
	
КонецПроцедуры

// Описание
// 
// Параметры:
// 	ДополнительныеПараметры - Структура - Описание:
// * ИмяКаталога - Строка -
// * МассивБиблиотек - Массив
// * ПерезаписыватьСуществующие - Булево
Процедура РаспаковатьБиблиотеки(ДополнительныеПараметры)
	
	Если Не ДополнительныеПараметры.МассивБиблиотек.Количество() Тогда
		ПослеЗагрузкиБиблиотек();
		Возврат;
	КонецЕсли;
	
	текущаяБиблиотека = ДополнительныеПараметры.МассивБиблиотек.Получить(0);

	КаталогРаспаковки = ДополнительныеПараметры.ИмяКаталога + текущаяБиблиотека + "\";
	ДополнительныеПараметры.Вставить("КаталогРаспаковки", КаталогРаспаковки);
	РаспаковатьКаталогПослеПроверкиНаличия = Новый ОписаниеОповещения(
		"РаспаковатьКаталогПослеПроверкиНаличия"
		, ЭтотОбъект
		, ДополнительныеПараметры);
	ФайлКаталога = Новый Файл(КаталогРаспаковки);
	ФайлКаталога.НачатьПроверкуСуществования(РаспаковатьКаталогПослеПроверкиНаличия);
	
КонецПроцедуры



// Описание
// 
// Параметры:
// 	Существует - Булево
// 	ДополнительныеПараметры - Структура - Описание:
// * ИмяКаталога - Строка -
// * МассивБиблиотек - Массив
// * ПерезаписыватьСуществующие - Булево
// * КаталогРаспаковки - Строка
Процедура РаспаковатьКаталогПослеПроверкиНаличия(Существует, ДополнительныеПараметры) Экспорт
		
	Если Существует Тогда 
		Если ДополнительныеПараметры.ПерезаписыватьСуществующие Тогда
			ОбработчикРаспаковкиПослеОчисткиКаталога
			= Новый ОписаниеОповещения("РаспаковатьПослеОчисткиКаталога"
				, ЭтотОбъект
				, ДополнительныеПараметры);
			НачатьУдалениеФайлов(ОбработчикРаспаковкиПослеОчисткиКаталога
				, ДополнительныеПараметры.КаталогРаспаковки
				, "*");	
		Иначе
			ДополнительныеПараметры.МассивБиблиотек.Удалить(0);
			РаспаковатьБиблиотеки(ДополнительныеПараметры);
		КонецЕсли;	
	Иначе
		ОбработчикРаспаковкиБиблиотекиВСуществующийКаталог 
		= Новый ОписаниеОповещения("РаспаковатьБиблиотекуВСуществующийКаталог"
			, ЭтотОбъект
			, ДополнительныеПараметры);
		НачатьСозданиеКаталога(ОбработчикРаспаковкиБиблиотекиВСуществующийКаталог
			, ДополнительныеПараметры.КаталогРаспаковки);
	КонецЕсли;
	
КонецПроцедуры

Процедура РаспаковатьПослеОчисткиКаталога(ДополнительныеПараметры) Экспорт
	
	РаспаковатьБиблиотекуВСуществующийКаталог(ДополнительныеПараметры.КаталогРаспаковки, ДополнительныеПараметры);
	
КонецПроцедуры

// Описание
// 
// Параметры:
// 	ИмяКаталога - Строка
// 	ДополнительныеПараметры - Структура - Описание:
// * ИмяКаталога - Строка -
// * МассивБиблиотек - Массив
// * ПерезаписыватьСуществующие - Булево
// * КаталогРаспаковки - Строка
Процедура РаспаковатьБиблиотекуВСуществующийКаталог(ИмяКаталога, ДополнительныеПараметры) Экспорт
	
	ТекущаяБиблиотека = ДополнительныеПараметры.МассивБиблиотек.Получить(0);
	АдресАрхива = пс_ПодключениеБиблиотекВызовСервера.ПоместитьВХранилищеОбщийМакет(ТекущаяБиблиотека);
	ДвоичныеДанные = ПолучитьИзВременногоХранилища(АдресАрхива);
	Если ТипЗнч(ДвоичныеДанные) = Тип("ДвоичныеДанные") Тогда
		#Если Не ВебКлиент Тогда
		Поток = ДвоичныеДанные.ОткрытьПотокДляЧтения();
		Чтение = Новый ЧтениеZipФайла(Поток);
		Чтение.ИзвлечьВсе(ИмяКаталога);
		Чтение.Закрыть();
		#КонецЕсли
	КонецЕсли;
	УдалитьИзВременногоХранилища(АдресАрхива);	
	пс_СкриптыВызовСервера.ПоместитьВСерверныйКэш(стрШаблон("АдресаБиблиотек.%1", ТекущаяБиблиотека),ИмяКаталога);
	ДополнительныеПараметры.МассивБиблиотек.Удалить(0);
	РаспаковатьБиблиотеки(ДополнительныеПараметры);
	
КонецПроцедуры

// Описание
// 
// Параметры:
// 	МассивБиблиотек - Массив - Описание
Процедура ПриОпределенииВнешнихБиблиотек(МассивБиблиотек)
	МассивБиблиотек.Добавить("пс_monaco");
КонецПроцедуры


Процедура ПослеЗагрузкиБиблиотек()
	ПодготовитьХТМЛРедактораКода();			
КонецПроцедуры

Процедура ПодготовитьХТМЛРедактораКода()
	
	#Если не ВебКлиент Тогда
	текстХТМЛ = 
	"<!DOCTYPE html>
	|<html>
	|	<head>
	|    	<meta http-equiv=""Content-Type"" content=""text/html;charset=utf-8"" >
	|		<script>%1</script>
	|		<script src=""%2package/min/vs/loader.js""></script>
	|		<script>require.config({ paths: { 'vs': '%2package/min/vs' }});</script>	
	|	</head>
	|	<body>
	|		<div id=""container"" style=""width: 98vw; height: 93vh;""></div>
	|	</body>
	|
	|	<script>		
	|    	require.config({
	|    	'vs/nls': {
	|        	availableLanguages: {
	|            	'*': ""ru""
	|				}
	|			}
	|		});
	|    	require(['vs/editor/editor.main'], function() {
	|        	self.editor = monaco.editor.create(document.getElementById('container'), {
//	|            	value: [
//	|                	'function x() {',
//	|                	'\tconsole.log(""Hello world!"");',
//	|                	'}'
//	|            	].join('\n'),
	|            	language: 'javascript'
	|        	});
	|    	});
	|	</script>		
	|</html>";
	// ToDo: получить за один вызов сервера, или запоминать не только на сервере но и на клиенте
	АдресОсновногоСкрипта = пс_СкриптыВызовСервера.АдресОсновногоРасширенияСкриптов();
	Поток = ПолучитьИзВременногоХранилища(АдресОсновногоСкрипта).ОткрытьПотокДляЧтения();
	ЧтениеТекста = Новый ЧтениеТекста(Поток, КодировкаТекста.UTF8);
	АдресБиблиоткиРедактора = пс_СкриптыВызовСервера.ПолучитьИзСерверногоКэша("АдресаБиблиотек.пс_monaco");
	АдресБиблиоткиРедактора = СтрЗаменить(АдресБиблиоткиРедактора, "\", "/");
	текстХТМЛ = СтрШаблон(текстХТМЛ, ЧтениеТекста.Прочитать(), АдресБиблиоткиРедактора);
	ЧтениеТекста.Закрыть();
		
	Док = Новый ЗаписьТекста(АдресБиблиоткиРедактора + "editor.html");
	Док.Записать(текстХТМЛ);
	Док.Закрыть();
	#КонецЕсли
КонецПроцедуры



